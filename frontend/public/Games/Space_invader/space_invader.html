<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Space Invaders</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas {
        background: #000;
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="595" height="395"></canvas>
    <script>
      const canvas = document.getElementById("myCanvas");
      const ctx = canvas.getContext("2d");
      
      // Player ship
      const player = {
        x: canvas.width / 2,
        y: canvas.height - 40,
        width: 30,
        height: 20,
        speed: 10,
        lives: 3
      };

      function drawPlayer() {
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        // Triangle shape for ship
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(player.x - player.width/2, player.y + player.height);
        ctx.lineTo(player.x + player.width/2, player.y + player.height);
        ctx.closePath();
        ctx.fill();
      }

      function movePlayerLeft() {
        player.x -= player.speed;
        if (player.x < player.width/2) player.x = player.width/2;
      }

      function movePlayerRight() {
        player.x += player.speed;
        if (player.x > canvas.width - player.width/2) {
          player.x = canvas.width - player.width/2;
        }
      }

      class Invader {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.width = 25;
          this.height = 20;
          this.type = type; // 0, 1, or 2 for different alien types
          this.alive = true;
        }

        draw(animFrame) {
          if (!this.alive) return;

          ctx.fillStyle = this.type === 0 ? '#ff0000' : 
                          this.type === 1 ? '#00ffff' : '#ffff00';

          // Simple alien shape (changes with animation)
          if (animFrame) {
            // Frame 1
            ctx.fillRect(this.x - 10, this.y - 5, 20, 10);
            ctx.fillRect(this.x - 12, this.y - 2, 4, 8);
            ctx.fillRect(this.x + 8, this.y - 2, 4, 8);
          } else {
            // Frame 2
            ctx.fillRect(this.x - 10, this.y - 5, 20, 10);
            ctx.fillRect(this.x - 15, this.y, 4, 8);
            ctx.fillRect(this.x + 11, this.y, 4, 8);
          }
        }
      }

      // Create invader grid
      const invaders = [];
      const ROWS = 5;
      const COLS = 11;
      let invaderDirection = 1; // 1 = right, -1 = left
      let invaderSpeed = 2;
      let invaderDropAmount = 15;
      let animationFrame = false;

      function createInvaders() {
        invaders.length = 0;
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            const type = row < 1 ? 0 : row < 3 ? 1 : 2;
            invaders.push(new Invader(
              80 + col * 40,
              50 + row * 35,
              type
            ));
          }
        }
      }

      createInvaders();

      class Bullet {
        constructor(x, y, speedY, isPlayerBullet) {
          this.x = x;
          this.y = y;
          this.speedY = speedY;
          this.width = 3;
          this.height = 10;
          this.isPlayerBullet = isPlayerBullet;
          this.active = true;
        }

        update() {
          this.y += this.speedY;

          // Remove if off screen
          if (this.y < 0 || this.y > canvas.height) {
            this.active = false;
          }
        }

        draw() {
          ctx.fillStyle = this.isPlayerBullet ? '#ffffff' : '#ff00ff';
          ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
        }
      }

      class Shield {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 50;
          this.height = 30;
          this.hits = Array(5).fill().map(() => Array(3).fill(true));
        }

        draw() {
          const blockW = this.width / 5;
          const blockH = this.height / 3;

          ctx.fillStyle = '#00ff00';
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 5; col++) {
              if (this.hits[col][row]) {
                ctx.fillRect(
                  this.x + col * blockW,
                  this.y + row * blockH,
                  blockW - 1,
                  blockH - 1
                );
              }
            }
          }
        }

        checkHit(bullet) {
          if (bullet.x < this.x || bullet.x > this.x + this.width ||
              bullet.y < this.y || bullet.y > this.y + this.height) {
            return false;
          }

          const col = Math.floor((bullet.x - this.x) / (this.width / 5));
          const row = Math.floor((bullet.y - this.y) / (this.height / 3));

          if (col >= 0 && col < 5 && row >= 0 && row < 3) {
            if (this.hits[col][row]) {
              this.hits[col][row] = false;
              return true;
            }
          }
          return false;
        }
      }

      const shields = [
        new Shield(100, canvas.height - 100),
        new Shield(250, canvas.height - 100),
        new Shield(400, canvas.height - 100)
      ];


      const bullets = [];
      let lastShootTime = 0;
      const shootCooldown = 300; // ms

      function shootPlayerBullet() {
        const now = Date.now();
        if (now - lastShootTime > shootCooldown) {
          bullets.push(new Bullet(player.x, player.y, -5, true));
          lastShootTime = now;
        }
      }

      function shootInvaderBullet() {
        // Random invader shoots
        const aliveInvaders = invaders.filter(inv => inv.alive);
        if (aliveInvaders.length > 0 && Math.random() < 0.02) {
          const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
          bullets.push(new Bullet(shooter.x, shooter.y + 10, 3, false));
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        requestAnimationFrame(draw);
      }
      
      function checkCollisions() {
        bullets.forEach(bullet => {
          if (!bullet.active) return;

          if (bullet.isPlayerBullet) {
            // Check bullet vs invaders
            invaders.forEach(invader => {
              if (!invader.alive) return;

              if (bullet.x > invader.x - invader.width/2 &&
                  bullet.x < invader.x + invader.width/2 &&
                  bullet.y < invader.y + invader.height/2 &&
                  bullet.y > invader.y - invader.height/2) {
                invader.alive = false;
                bullet.active = false;
                score += (invader.type + 1) * 10;
                  
                // Check if all dead
                if (invaders.every(inv => !inv.alive)) {
                  levelTransition = true;
                  setTimeout(levelComplete, 1);
                }
              }
            });
          } else {
            // Check invader bullet vs player
            if (bullet.x > player.x - player.width/2 &&
                bullet.x < player.x + player.width/2 &&
                bullet.y > player.y &&
                bullet.y < player.y + player.height) {
              bullet.active = false;
              player.lives--;
                
              if (player.lives <= 0) {
                gameOver = true;
              }
            }
          }
        });

        // Remove inactive bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          if (!bullets[i].active) {
            bullets.splice(i, 1);
          }
        }
      }

      let invaderMoveCounter = 0;
      let invaderMoveDelay = 30; // frames between moves

      function moveInvaders() {
        invaderMoveCounter++;

        if (invaderMoveCounter < invaderMoveDelay) return;
        invaderMoveCounter = 0;

        // Animate
        animationFrame = !animationFrame;

        // Check if any invader hit edge
        let hitEdge = false;
        invaders.forEach(invader => {
          if (!invader.alive) return;

          if ((invaderDirection > 0 && invader.x > canvas.width - 40) ||
              (invaderDirection < 0 && invader.x < 40)) {
            hitEdge = true;
          }
        });

        if (hitEdge) {
          // Drop down and reverse
          invaderDirection *= -1;
          invaders.forEach(invader => {
            invader.y += invaderDropAmount;

            // Check if invaders reached bottom
            if (invader.alive && invader.y > canvas.height - 60) {
              gameOver = true;
            }
          });
        } else {
          // Move horizontally
          invaders.forEach(invader => {
            invader.x += invaderSpeed * invaderDirection;
          });
        }
      }

      let lastMoveTime = 0;
      const moveCooldown = 50;

      window.addEventListener("message", (event) => {
        if (!event.data || !event.data.type || gameOver) return;
        const command = event.data.type;
        const now = Date.now();

        const parts = command.split(" ");
        if (parts.length !== 2) return;

        const direction = parts[1];

        if (direction === "left") {
          if (now - lastMoveTime > moveCooldown) {
            movePlayerLeft();
            lastMoveTime = now;
          }
        } else if (direction === "right") {
          if (now - lastMoveTime > moveCooldown) {
            movePlayerRight();
            lastMoveTime = now;
          }
        } else if (direction === "up" || direction === "down") {
          shootPlayerBullet();
        }
      });

      let score = 0;
      let gameOver = false;
      let level = 1;
      let levelTransition = false;

      function update() {
        if (gameOver) return;

        moveInvaders();
        shootInvaderBullet();

        bullets.forEach(bullet => bullet.update());
        checkCollisions();

        // Check shields
        bullets.forEach(bullet => {
          if (!bullet.active) return;
          shields.forEach(shield => {
            if (shield.checkHit(bullet)) {
              bullet.active = false;
            }
          });
        });
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw everything
        drawPlayer();
        invaders.forEach(inv => inv.draw(animationFrame));
        bullets.forEach(bullet => bullet.draw());
        shields.forEach(shield => shield.draw());

        // Draw UI
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`Score: ${score}`, 10, 20);
        ctx.fillText(`Lives: ${player.lives}`, canvas.width - 80, 20);
        ctx.fillText(`Level: ${level}`, canvas.width / 2 - 30, 20);

        if (levelTransition) {
          ctx.fillStyle = '#00ff00';
          ctx.font = '30px Arial';
          ctx.fillText('LEVEL COMPLETE!', canvas.width/2 - 130, canvas.height/2);
        }

        if (gameOver) {
          ctx.fillStyle = '#ff0000';
          ctx.font = '40px Arial';
          ctx.fillText('GAME OVER', canvas.width/2 - 120, canvas.height/2);
        }

        update();
        requestAnimationFrame(draw);
      }

      function levelComplete() {
        level++;
        invaderSpeed += 0.5;
        invaderMoveDelay = Math.max(10, invaderMoveDelay - 5);
        createInvaders();
        bullets.length = 0;
        levelTransition = false;
      }

      draw();
    </script>
  </body>
</html>